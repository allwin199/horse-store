// 0x6080604052 348015600e575f80fd5b5060a58061001b5f395ff3fe6080604052348015600e575f80fd5b50600436106030575f3560e01c8063cdfead2e146034578063e026c017146045575b5f80fd5b6043603f3660046059565b5f55565b005b5f5460405190815260200160405180910390f35b5f602082840312156068575f80fd5b503591905056fea2646970667358221220980ac8943021213b79b5c64bf1cf6912313f6103ef0e84513355325a5d7b0d3e64736f6c63430008140033

// 3 sections:
// 1. Contract Creation
// 2. Runtime (what actually is stored in the blockchain)
// 3. Metadata (details about compiler version etc...)


// 0x6080604052 -> Contract Creation Code
// Free Memory Pointer
PUSH1 0x80              // [0x80]
PUSH1 0x40              // [0x40, 0x80]  
MSTORE

CALLVALUE
DUP1
ISZERO
PUSH1 0x0e
JUMPI
PUSH0
DUP1
REVERT
JUMPDEST
POP
PUSH1 0xa5
DUP1
PUSH2 0x001b
PUSH0
CODECOPY
PUSH0
RETURN
INVALID
PUSH1 0x80
PUSH1 0x40
MSTORE
CALLVALUE
DUP1
ISZERO
PUSH1 0x0e
JUMPI
PUSH0
DUP1
REVERT
JUMPDEST
POP
PUSH1 0x04
CALLDATASIZE
LT
PUSH1 0x30
JUMPI
PUSH0
CALLDATALOAD
PUSH1 0xe0
SHR
DUP1
PUSH4 0xcdfead2e
EQ
PUSH1 0x34
JUMPI
DUP1
PUSH4 0xe026c017
EQ
PUSH1 0x45
JUMPI
JUMPDEST
PUSH0
DUP1
REVERT
JUMPDEST
PUSH1 0x43
PUSH1 0x3f
CALLDATASIZE
PUSH1 0x04
PUSH1 0x59
JUMP
JUMPDEST
PUSH0
SSTORE
JUMP
JUMPDEST
STOP
JUMPDEST
PUSH0
SLOAD
PUSH1 0x40
MLOAD
SWAP1
DUP2
MSTORE
PUSH1 0x20
ADD
PUSH1 0x40
MLOAD
DUP1
SWAP2
SUB
SWAP1
RETURN
JUMPDEST
PUSH0
PUSH1 0x20
DUP3
DUP5
SUB
SLT
ISZERO
PUSH1 0x68
JUMPI
PUSH0
DUP1
REVERT
JUMPDEST
POP
CALLDATALOAD
SWAP2
SWAP1
POP
JUMP
INVALID
LOG2
PUSH5 0x6970667358
INVALID
SLT
SHA3
SWAP9
EXP
INVALID
SWAP5
ADDRESS
INVALID
INVALID
EXTCODESIZE
PUSH26 0xb5c64bf1cf6912313f6103ef0e84513355325a5d7b0d3e64736f
PUSH13 0x63430008140033


// 1. Contract Creation Code
// 0x6080604052
// This setup will be same for every solidity smart contract
// This is also known as Free Memory Pointer
// 0x60 -> PUSH1	
// Place 1 byte item on stack
// PUSH1 0x80        // [0x80]
// PUSH1 0x40        // [0x40, 0x80] // top of the stack contains `0x40` and botttom contains `0x80`
// MSTORE            // []
// Stack input
// 1. offset: offset in the memory in bytes.
// 2. value: 32-byte value to write in the memory.
// `offset` will be whatever present at the top of the stack
// `value` will be whatever present at the bottom
// Inside the memory at position `0x40` save the value `0x80` 
