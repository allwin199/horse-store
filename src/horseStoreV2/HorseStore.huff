/* Import */
#include "../../lib/huffmate/src/data-structures/Hashmap.huff"

/* HorseStore Interace */
#define function mintHorse() nonpayable returns()
#define function feedHorse(uint256) nonpayable returns()
#define function isHappyHorse(uint256) view returns(bool)
#define function horseIdToFedTimeStamp(uint256) view returns(uint256)
#define function HORSE_HAPPY_IF_FED_WITHIN() view returns(uint256)

// Storage Slot
#define constant HORSE_FED_TIMESTAMP_LOCATION = FREE_STORAGE_POINTER()
// this will be storage slot for mapping
#define constant HORSE_HAPPY_IF_FED_WITHIN_CONST = 0x0000000000000000000000000000000000000000000000000000000000015180
// 1 days in hex
// use chisel

#define macro MINT_HORSE() = takes(0) returns(0) {}

#define macro FEED_HORSE() = takes(0) returns(0) {
    timestamp                // [timestamp] will be on the stack
    0x04 calldataload        // [calldata_without_selector, timestamp] // calldata_without_selector will have value about `horseId`

    // we have [horseId, timestamp] in the stack
    // we need to `sstore` this timestamp for the `horseId`
    // we also need a storage slot
    [HORSE_FED_TIMESTAMP_LOCATION]       // [HORSE_FED_TIMESTAMP_LOCATION, horseId, timestamp]
    
    STORE_ELEMENT_FROM_KEYS(0x00)        // []
    // (0x00) is the free memory pointer
    // STORE_ELEMENT_FROM_KEYS from `huffmate` will pop 3 items of the stack and returns 0
    // It will go to `HORSE_FED_TIMESTAMP_LOCATION` and for `horseId` update the `timestamp`

    stop

}

#define macro IS_HAPPY_HORSE() = takes(0) returns(0) {
    0x04 calldataload                     // [calldata_without_selector]

    [HORSE_FED_TIMESTAMP_LOCATION]        // [HORSE_FED_TIMESTAMP_LOCATION, horseId]

    LOAD_ELEMENT_FROM_KEYS(0x00)          // [horseFedTimeStamp]

    timestamp                             // [timestamp, horseFedTimeStamp]

    dup2                                  // [horseFedTimeStamp, timestamp, horseFedTimeStamp]
    
    dup2                                  // [timestamp, horseFedTimeStamp, timestamp, horseFedTimeStamp]

    sub                                   // [timestamp - horseFedTimeStamp, timestamp, horseFedTimeStamp]

    [HORSE_HAPPY_IF_FED_WITHIN_CONST]     
    // [HORSE_HAPPY_IF_FED_WITHIN_CONST, timestamp - horseFedTimeStamp, timestamp, horseFedTimeStamp]

    gt  
    // [HORSE_HAPPY_IF_FED_WITHIN_CONST > timestamp - horseFedTimeStamp, timestamp, horseFedTimeStamp]  
    // (HORSE_HAPPY_IF_FED_WITHIN_CONST > timestamp - horseFedTimeStamp) will return true if horse has fed within 1 days, or else false.
    //  [horse_has_been_fed_within_1_day, timestamp, horseFedTimeStamp]  will be in the stack

    start_return_true                      // [horse_has_been_fed_within_1_day, timestamp, horseFedTimeStamp]
    jumpi                                  // [timestamp, horseFedTimeStamp]
    // if `horse_has_been_fed_within_1_day` returns `true` then Jump
    // If this is true, then it will jump to start_return and return `true`
    // else it will continue    

    eq                                     // [timestamp == horseFedTimeStamp]
    
    start_return                           // [timestamp == horseFedTimeStamp]
    jumpi
    

    start_return_true:
    0x01                                    // [0x01, timestamp, horseFedTimeStamp]
    // 0x01 will be true

    start_return:
    0x00 mstore                             // [] // Memory: [0x00: true or false]

    0x20 0x00 return

}

#define macro GET_HORSE_FED_TIMESTAMP() = takes(0) returns(0) {
    // horseIdToFedTimeStamp will return the last_timestamp for the horseId
    // we need storage slot of `horseIdToFedTimeStamp`
    // we need `horseId`. 
    // we get the value from storage, we cannot return from storage
    // pop it into memory and return it

    0x04 calldataload                       // [calldata_without_selector] 
    // calldata_without_selector will have value about `horseId`
    
    [HORSE_FED_TIMESTAMP_LOCATION]          // [HORSE_FED_TIMESTAMP_LOCATION, horseId]

    LOAD_ELEMENT_FROM_KEYS(0x00)            // [horseFedTimeStamp]

    0x00 mstore                             // []     // Memory: [0x00: horseFedTimeStamp]

    0x20 0x00 return                        // []
    // size of the value is 0x20(32 bytes)
    // value is in slot 0x00 in memory
    // which means we are going to take 32 bytes starting from 0th poisition in memory and return
}

#define macro HORSE_HAPPY_IF_FED_WITHIN() = takes(0) returns(0) {
    [HORSE_HAPPY_IF_FED_WITHIN_CONST]       // [HORSE_HAPPY_IF_FED_WITHIN_CONST]

    0x00 mstore                             // [] Memory [0x00 : HORSE_HAPPY_IF_FED_WITHIN_CONST]

    0x20 0x00 return
}

#define macro MAIN() = takes(0) returns(0) {
    0x00 calldataload 0xe0 shr             

    dup1 __FUNC_SIG(mintHorse) eq mintHorse jumpi  
    
    dup1 __FUNC_SIG(feedHorse) eq feedHorse jumpi
    // do we have to do dup1 again?      

    dup1 __FUNC_SIG(isHappyHorse) eq isHappyHorse jumpi

    dup1 __FUNC_SIG(horseIdToFedTimeStamp) eq horseIdToFedTimeStamp jumpi

    dup1 __FUNC_SIG(HORSE_HAPPY_IF_FED_WITHIN) eq horseHappyFedWithin jumpi

    0x00 0x00 revert

    mintHorse:
        MINT_HORSE()

    feedHorse:
        FEED_HORSE()

    isHappyHorse:
        IS_HAPPY_HORSE()

    horseIdToFedTimeStamp:
        GET_HORSE_FED_TIMESTAMP()

    horseHappyFedWithin:
        HORSE_HAPPY_IF_FED_WITHIN()
}

// 0x00 calldatatoload 0xe0 shr              
// the above opcodes will strip the `function_selector` out of the calldata.
// then push function_selector on the stack

// dup1 __FUNC_SIG(mintHorse) eq mintHorse jumpi  
// duplicate the function selector and then get the function_selector for `mintHorse`
// If both are equal Jump to `mintHorse` macro
// else continue

// dup1 __FUNC_SIG(feedHorse) eq feedHorse jumpi
// duplicate the function selector and then get the function_selector for `feedHorse`
// If both are equal Jump to `feedHorse` macro
// else continue